package main

import (
	"fmt"
	"math"
)

// Функция уравнения: f(x) = x * ln(x + 2) - 2
func f(x float64) float64 {
	return x*math.Log(x+2) - 2
}

// Производная функции: f'(x) = ln(x + 2) + x / (x + 2)
func df(x float64) float64 {
	return math.Log(x+2) + x/(x+2)
}

// Метод половинного деления для нахождения корня уравнения на интервале [a, b]
func bisection(a, b, e float64) {
	fmt.Println("Метод половинного деления:")
	fmt.Println("N\t a_n\t\t b_n\t\t b_n - a_n")
	n := 0          // Счетчик итераций
	var c float64   // Точка деления интервала

	// Продолжаем, пока длина интервала больше заданной точности
	for b-a > e {
		c = (a + b) / 2 // Находим середину интервала
		fmt.Printf("%d\t %.6f\t %.6f\t %.6f\n", n, a, b, b-a)

		// Если значение функции в точке c равно 0, корень найден
		if f(c) == 0 {
			break
		}

		// Выбираем новый интервал в зависимости от знака функции
		if f(a)*f(c) < 0 {
			b = c // Корень в левой половине
		} else {
			a = c // Корень в правой половине
		}
		n++
	}
	fmt.Printf("Корень: %.6f\n\n", c)
}

// Метод Ньютона
func newton(x0, e float64) {
	fmt.Println("Метод Ньютона:")
	fmt.Println("N\t X_n\t\t X_{n+1}\t\t X_{n+1} - X_n")
	n := 0          // Счетчик итераций
	var x1 float64   // Новое приближение

	for {
		// Формула метода Ньютона: x_{n+1} = x_n - f(x_n)/f'(x_n)
		x1 = x0 - f(x0)/df(x0)
		fmt.Printf("%d\t %.6f\t %.6f\t %.6f\n", n, x0, x1, math.Abs(x1-x0))

		// Проверяем условие выхода (достижение заданной точности)
		if math.Abs(x1-x0) < e {
			break
		}

		x0 = x1 // Обновляем текущее приближение
		n++

		// Защита от бесконечного цикла
		if n >= 1000 {
			fmt.Println("Ошибка: Превышено максимальное число итераций")
			return
		}
	}
	fmt.Printf("Корень: %.6f\n\n", x1)
}

// Метод простых итераций
// Уравнение x = 2 / ln(x + 2)
func simpleIteration(x0, e float64) {
	fmt.Println("Метод простых итераций:")
	fmt.Println("N\t X_n\t\t X_{n+1}\t\t X_{n+1} - X_n")
	n := 0          // Счетчик итераций
	var x1 float64   // Новое приближение

	const maxIter = 100 // Максимальное число итераций

	for {
		denom := math.Log(x0 + 2) // Знаменатель: ln(x0 + 2)

		// Проверка на деление на ноль или очень маленькое значение
		if math.Abs(denom) < 1e-10 {
			fmt.Printf("Ошибка: Деление на ноль или почти ноль (x_n = %.6f)\n", x0)
			return
		}

		// Итерационная формула: x_{n+1} = 2 / ln(x_n + 2)
		x1 = 2 / denom
		fmt.Printf("%d\t %.6f\t %.6f\t %.6f\n", n, x0, x1, math.Abs(x1-x0))

		// Проверяем условие выхода (достижение заданной точности)
		if math.Abs(x1-x0) < e {
			break
		}

		x0 = x1 // Обновляем текущее приближение
		n++

		// Защита от бесконечного цикла
		if n >= maxIter {
			fmt.Println("Ошибка: Превышено максимальное число итераций")
			return
		}
	}
	fmt.Printf("Корень: %.6f\n\n", x1)
}

// Метод простых итераций для отрицательного корня
func simpleIterationN(x0, e float64) {
	fmt.Println("Метод простых итераций (отрицательный корень):")
	fmt.Println("N\t X_n\t\t X_{n+1}\t\t X_{n+1} - X_n")
	n := 0          // Счетчик итераций
	var x1 float64   // Новое приближение

	const maxIter = 100 // Максимальное число итераций

	for {
		// Итерационная формула: x_{n+1} = exp(2 / x_n) - 2
		x1 = math.Exp(2/x0) - 2

		fmt.Printf("%d\t %.6f\t %.6f\t %.6f\n", n, x0, x1, math.Abs(x1-x0))

		// Проверяем условие выхода (достижение заданной точности)
		if math.Abs(x1-x0) < e {
			break
		}

		x0 = x1 // Обновляем текущее приближение
		n++

		// Защита от бесконечного цикла
		if n >= maxIter {
			fmt.Println("Ошибка: Превышено максимальное число итераций")
			return
		}
	}
	fmt.Printf("Корень: %.6f\n\n", x1)
}

func main() {
	e := 1e-4 // Точность вычислений

	// Метод половинного деления на интервале [1, 2] и [-2, -1]
	bisection(1.0, 2.0, e)
	bisection(-2.0, -1.0, e)

	// Метод Ньютона с начальным приближением x0 = 1.5 и x0 = -1.5
	newton(1.5, e)
	newton(-1.5, e)

	// Метод простых итераций с начальным приближением x0 = 1.5
	simpleIteration(1.5, e)
	simpleIterationN(-1.5, e)
}
